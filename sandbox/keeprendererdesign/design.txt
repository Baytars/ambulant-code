Notes on design of keep-renderers
=================================

I assume that we are implementing only part of the official SMIL spec for prefetch:
we ignore the bandwidth and size parameters, and we ignore the scheduler aspects (begin,
end, dur). We simply start prefetching data until our datasource buffers are filled
to capacity.

I assume the following interface for the renderer and playable (the important bits).
This is slightly different from what is currently implemented.
All methods are from playable, unless otherwise indicated.

playable and renderer API
-------------------------

create(event_processor *evp, playable_notification *context)	
	/// Constructor function.
	
init_with_node(node *n)
	/// Bind the renderer to a node, either prefetch or media.
	/// Records node, URL, cookie, clip_begin/end, etc.
	
renderer::set_surface(surface *dest)
	/// Bind renderer output to a surface.
	
preroll(double when, double where, double how_much)
	/// If the datasource is not open yet it is opened and positioned.
	/// If the datasource is already opened it is re-positioned, unless the new
	/// start position is equal to the old "official" current position.
	/// start reading data.
	/// Record where as old "official" position.
	/// when and how_much are ignored.
	
start(double t, playable_notification::cookie_type cookie)
	/// preroll(0, t, 0)
	/// assert(surface)
	/// Start rendering media.
	/// Synchronize media clock.
	
stop()
	/// Scheduler-aspect of stop: emits stopped(), removes node/cookie binding.
	/// Playback continues, though.

post_stop()
	/// Playback stops.
	
I'm ignoring pause(), resume(), seek() and wantclicks() here, as they have no influence
on the grand scheme of things. I am assuming that these calls can only be issued
between start() and stop(). We want to put assert()s in to check this.

playable_notification interface
-------------------------------

The notification interface is unchanged:

started(cookie)
	/// Emitted when the node starts playback
	
stopped(cookie)
	/// Emitted when the node stops playback
	
All the other ones can only occur between those two. Every
start() will generate exactly one started(). Exactly one stopped() is always emitted,
after started(). stopped() may be emitted before or after stop().

internal events
---------------

There are a number of internal events (internal to the renderer) that also
cause state changes:

END_OF_FILE
	/// The data source signals end-of-file
	
END_OF_CLIP
	/// The data source position goes past clipEnd.

API call sequences
------------------

For a normal node, that is not followed by a second node referring to the same URL,
the order of calls will be:
	
	create()
	init_with_node(node)
	set_surface(node_surface)
	preroll(node_parameters)
	start()
	stop()
	post_stop()
	
For two nodes back-to-back, the order will be:

	create()
	init_with_node(node1)
	set_surface(node1_surface)
	preroll(node1_parameters)
	start()
	stop()
	init_with_node(node2)
	set_surface(node2_surface)
	preroll(node2_parameters)
	start()
	stop()
	post_stop()
	
There is now the question of how to handle mismatching surfaces. Probably not difficult, but we need
to be aware of it.

For a prefetch, later followed by a normal node, the order will be:

	create()
	init_with_node(prefetch_node)
	preroll(prefetch_node_parameters)
	init_with_node(normal_node)
	set_surface(normal_node_surface)
	preroll(normal_node_parameters)
	start()
	stop()
	post_stop()
	
Changes, and rationale
----------------------

I've split the constructor into two, effectively putting all the functionality that was duplicated
in update_context_info() into the (very similar) new init_with_node().

I've moved initialization of context::cookie to start(): if start is never called the
renderer should never ever do callbacks.

I've removed start_prefetch(), because we already had an (unused, and forgotten) API
called preroll().

Bo's call stop_but_keeping_renderer() is now called simply stop(). The "second half"
of the old stop, which actually stops playback, is now called post_stop().